import { Link, Warning } from '@brillout/docpress'
import { Tab, Tabs, TabList, TabPanel } from 'react-tabs'
import '../../components/tabs.css'
import PhotonBuiltInServer from '../vike-photon/PhotonBuiltInServer.mdx'
import { UseScaffolder } from '../../components'
import { Example } from '../../components'
import { VikePhotonBetaWarning } from '../vike-photon/BetaWarning'

We recommend using [Photon](https://photonjs.dev) for a seamless and full-fledged [Vercel](https://vercel.com) integration, including [Incremental Static Regeneration (ISR)](https://vercel.com/docs/concepts/incremental-static-regeneration/overview).

> Alternatively, for more control, you can <Link href="#manual-integration">manually integrate Vercel</Link> instead of using Photon.

<VikePhotonBetaWarning />


## Get started

### Scaffold new app

<UseScaffolder>Vercel with Photon</UseScaffolder>

### Add to existing app

> If you <Link href="/pre-rendering#partial">pre-render your pages only partially</Link>, you can also use <Link href="/vike-photon" /> to statically deploy your pre-rendered pages while dynamically serving your SSR pages.

<Tabs>
  <TabList>
    <Tab>npm</Tab>
    <Tab>pnpm</Tab>
    <Tab>yarn</Tab>
  </TabList>
  <TabPanel>
    ```shell
    npm i vike-photon @photonjs/vercel
    ```
  </TabPanel>
  <TabPanel>
    ```shell
    pnpm add vike-photon @photonjs/vercel
    ```
  </TabPanel>
  <TabPanel>
    ```shell
    yarn add vike-photon @photonjs/vercel
    ```
  </TabPanel>
</Tabs>

```ts
// pages/+config.ts

import type { Config } from 'vike/types'
import vikePhoton from 'vike-photon/config'// [!code ++]

export default {
  extends: [vikePhoton],// [!code ++]
  // (optional) if you installed a server
  photon: {// [!code ++]
    server: 'server/index.ts'// [!code ++]
  }// [!code ++]
} satisfies Config
```

> Under the hood, `@photonjs/vercel` uses Vercel's [Build Output API](https://vercel.com/docs/build-output-api/v3).

### Server

<PhotonBuiltInServer />

```ts
// pages/+config.ts

import type { Config } from 'vike/types'
import vikePhoton from 'vike-photon/config'

export default {
  extends: [vikePhoton],
  photon: {// [!code ++]
    server: 'server/index.ts'// [!code ++]
  }// [!code ++]
} satisfies Config
```

<Tabs>
  <TabList>
    <Tab>Express.js</Tab>
    <Tab>Hono</Tab>
    <Tab>Fastify</Tab>
    <Tab>H3</Tab>
    <Tab>Elysia</Tab>
  </TabList>

  <TabPanel>
    <Tabs>
      <TabList>
        <Tab>npm</Tab>
        <Tab>pnpm</Tab>
        <Tab>yarn</Tab>
      </TabList>
      <TabPanel>
        ```shell
        npm i express @photonjs/express
        ```
      </TabPanel>
      <TabPanel>
        ```shell
        pnpm add express @photonjs/express
        ```
      </TabPanel>
      <TabPanel>
        ```shell
        yarn add express @photonjs/express
        ```
      </TabPanel>
    </Tabs>
    ```ts
    // server/index.ts

    import express from 'express'
    import { apply, serve } from '@photonjs/express'// [!code ++]

    function startServer() {
      const app = express()
      apply(app)// [!code ++]
      return serve(app)// [!code ++]
    }

    export default startServer()// [!code ++]
    ```
  </TabPanel>
  <TabPanel>
    <Tabs>
      <TabList>
        <Tab>npm</Tab>
        <Tab>pnpm</Tab>
        <Tab>yarn</Tab>
      </TabList>
      <TabPanel>
        ```shell
        npm i hono @photonjs/hono
        ```
      </TabPanel>
      <TabPanel>
        ```shell
        pnpm add hono @photonjs/hono
        ```
      </TabPanel>
      <TabPanel>
        ```shell
        yarn add hono @photonjs/hono
        ```
      </TabPanel>
    </Tabs>
    ```ts
    // server/index.ts

    import { Hono } from 'hono'
    import { apply, serve } from '@photonjs/hono'// [!code ++]

    function startServer() {
      const app = new Hono()
      apply(app)// [!code ++]
      return serve(app)// [!code ++]
    }

    export default startServer()// [!code ++]
    ```
  </TabPanel>
  <TabPanel>
      <Tabs>
        <TabList>
          <Tab>npm</Tab>
          <Tab>pnpm</Tab>
          <Tab>yarn</Tab>
        </TabList>
        <TabPanel>
          ```shell
          npm i fastify fastify-raw-body @photonjs/fastify
          ```
        </TabPanel>
        <TabPanel>
          ```shell
          pnpm add fastify fastify-raw-body @photonjs/fastify
          ```
        </TabPanel>
        <TabPanel>
          ```shell
          yarn add fastify fastify-raw-body @photonjs/fastify
          ```
        </TabPanel>
      </Tabs>
      ```ts
      // server/index.ts

      import Fastify from 'fastify'
      import rawBody from 'fastify-raw-body'// [!code ++]
      import { apply, serve } from '@photonjs/fastify'// [!code ++]

      async function startServer() {
        const app = Fastify({// [!code ++]
          // ⚠️ Mandatory for HMR support
          forceCloseConnections: true// [!code ++]
        })// [!code ++]
        // ⚠️ Mandatory for Vike middlewares to operate properly
        await app.register(rawBody)// [!code ++]
        await apply(app)// [!code ++]
        return serve(app)// [!code ++]
      }

      export default await startServer()// [!code ++]
      ```
    </TabPanel>
    <TabPanel>
      <Tabs>
        <TabList>
          <Tab>npm</Tab>
          <Tab>pnpm</Tab>
          <Tab>yarn</Tab>
        </TabList>
        <TabPanel>
          ```shell
          npm i h3 @photonjs/h3
          ```
        </TabPanel>
        <TabPanel>
          ```shell
          pnpm add h3 @photonjs/h3
          ```
        </TabPanel>
        <TabPanel>
          ```shell
          yarn add h3 @photonjs/h3
          ```
        </TabPanel>
      </Tabs>
      ```ts
      // server/index.ts

      import { createApp } from 'h3'
      import { apply, serve } from '@photonjs/h3'// [!code ++]

      function startServer() {
        const app = createApp()
        apply(app)// [!code ++]
        return serve(app)// [!code ++]
      }

      export default startServer()// [!code ++]
      ```
    </TabPanel>
    <TabPanel>
      <Tabs>
        <TabList>
          <Tab>npm</Tab>
          <Tab>pnpm</Tab>
          <Tab>yarn</Tab>
        </TabList>
        <TabPanel>
          ```shell
          npm i elysia @photonjs/elysia
          ```
        </TabPanel>
        <TabPanel>
          ```shell
          pnpm add elysia @photonjs/elysia
          ```
        </TabPanel>
        <TabPanel>
          ```shell
          yarn add elysia @photonjs/elysia
          ```
        </TabPanel>
      </Tabs>
      ```ts
      // server/index.ts

      import { Elysia } from 'elysia'
      import { apply, serve } from '@photonjs/elysia'// [!code ++]

      function startServer() {
        const app = new Elysia()
        apply(app)// [!code ++]
        return serve(app)// [!code ++]
      }

      export default startServer()// [!code ++]
      ```
    </TabPanel>
</Tabs>

> See <Link href="/vike-photon" /> for the list of options.

## Advanced options

### ISR

Vike supports [Incremental Static Regeneration (ISR)](https://vercel.com/docs/concepts/incremental-static-regeneration/overview) when using Photon.

```ts
// pages/some-route/+config.ts

import type { Config } from 'vike/types'

export default {
  // Options
  isr: {
    // Expiration time (in seconds) before the cached asset is re-generated
    expiration: 30
  },
} satisfies Config
```

## Deployment

You can deploy your app using either Vercel's CLI or Vercel's Git integration.

### CLI

Install the [Vercel CLI](https://vercel.com/docs/cli), then run the `vercel` command.
The CLI will guide you through the necessary steps.

### Git

See the [official documentation](https://vercel.com/docs/git#deploying-a-git-repository).


## Manual integration

### API Route

A simple way to integrate Vercel is to create a Vercel API Route `api/ssr.js` that server-side renders your app.

Example:
 - <Example timestamp="2024.03" repo="brillout/vike-with-vercel" />
<Warning>Make sure to properly set `OUTPUT DIRECTORY` in your Vercel dashboard, see the example's `README.md` instructions.</Warning>

> Using a Vercel API Route is a sturdy way to deploy to Vercel, as API Routes is a core Vercel feature: it's here to stay and, most importantly, stable. (Whereas Vercel's Build Output API is a moving target with occasional breaking changes.) Once you've set the server-side rendering API Route, you can expect it to work for the foreseeable future.


### Build Output API

For maximum flexibility and configuration options, you can use the [Build Output API](https://vercel.com/docs/build-output-api/v3) instead of an API route.

Example:
 - <Example timestamp="2022.07" repo="brillout/vite-plugin-ssr_vercel_build-output-api" />
   > vite-plugin-ssr was the [previous name of Vike](https://vite-plugin-ssr.com/vike).


### API Routes with development

Vercel API Routes only work in production on Vercel's platform. This means, you may need to re-create your API routes integration for development.

For example, you typically need to integrate your data layer twice:
 1. Using Vercel's API Routes, for Vercel deployment.
 1. Using a local server (e.g. Express.js), for development.

This is usually easy to achieve as most data layer tools integrate using a single HTTP endpoint. For example:
 - [GraphQL](https://graphql.org/) integrates over a single HTTP endpoint `/graphql`.
 - [Telefunc](https://telefunc.com/) integrates over a single HTTP endpoint `/_telefunc`.
 - [tRPC](https://trpc.io/) integrates over a single HTTP endpoint as well.

In other words, you can add a data layer by:
 - Creating a new Vercel API Route, integrating that single endpoint.
 - Creating a new route to your local development server (e.g. Express.js), integrating that single endpoint.
