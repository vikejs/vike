import { Link } from '@brillout/docpress'

If you're new to modern web development with JavaScript and [React](https://react.dev) or [Vue](https://vuejs.org), you might have heard the terms **SSR** (Server-Side Rendering) and **SPA** (Single Page Application) but aren't sure what they mean. This guide explains both concepts and their differences.

> If you're already familiar with SSR and SPA, see <Link href="/SPA-vs-SSR" /> instead.

A unique aspect about JavaScript is that it can run not only inside the browser (browsers support only two languages: [JavaScript](https://en.wikipedia.org/wiki/JavaScript) and [WebAssembly](https://webassembly.org)) but also on the server (by using a JavaScript runtime such as [Node.js](https://nodejs.org)).

This means that when you define a component like this:

// TODO: replace Hello.jsx with Welcome.jsx with content shown in the HTML snippet below
```jsx
// Hello.jsx

function Hello({ name }: { name: string }) {
  return <h1>Hello {name}</h1>
}
```

This JSX code is compiled (by [Vite](https://vite.dev)) to JavaScript and can be run on the client and/or the server.

**SPA** denotes the practice of rendering components only on the client-side (i.e. in the browser):

```jsx
// render.js
// Environment: client

import { Hello } from './Hello'

// Render <Hello> on the client-side
import { createRoot } from 'react-dom/client'
function App() {
  return <Hello name="Alice" />
}
const root = createRoot(document.getElementById('root'))
root.render(<App />)
```

The HTML delivered to the browser is minimal and doesn't contain the actual content:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>My SPA</title>
  </head>
  <body>
    <!-- Empty container: content will be added dynamically by the client-side JavaScript -->
    <div id="root"></div>
    <script src="/render.js"></script>
  </body>
</html>
```

**SSR** (**S**erver-**s**ide **r**endering) denotes the practice of rendering components to HTML on the server-side and <Link href="/hydration">hydrating</Link> (making them interactive) on the client-side.

```jsx
// ssr.js
// Environment: server

import { Hello } from './Hello'

// Render <Hello> to HTML on the server-side
import { renderToString } from 'react-dom/server'
function App() {
  return <Hello name="Alice" />
}
const html = renderToString(<App />)
```

```jsx
// hydrate.js
// Environment: client

import { Hello } from './Hello'

// Hydrate the app on the client-side
import { hydrateRoot } from 'react-dom/client'
function Hello({ name }) {
  return <h1>Hello {name}</h1>
}
function App() {
  return <Hello name="Alice" />
}
hydrateRoot(document.getElementById('root'), <App />)
```

The HTML delivered to the browser contains the actual content:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>My SSR App</title>
  </head>
  <body>
    <!-- Content is already here when the page loads -->
    <div id="root">
      <h1>Hello Alice</h1>
    </div>
    <script src="/hydrate.js"></script>
  </body>
</html>
```

Note how with SSR, the content `<h1>Hello Alice</h1>` is included in the HTML, but with SPA it's missing in the HTML.

This is the central functional difference between SSR and SPA: **with SSR the page's content is rendered to HTML whereas with SPA the HTML is just an empty shell**.

It matters for two reasons: crawlers (search engines and AI) and performance.


## Crawlers

The [crawlers](https://en.wikipedia.org/wiki/Web_crawler) of **search engines** (e.g. Google) and **social media sites** (e.g. Instagram, Twitter), and **AI** (e.g. ChatGPT) navigate your website by recursively reading the HTML of your pages while following `<a href="/some-other-page">` links found in the HTML.

With SPA, a crawler only sees an empty HTML.

```html
<-- ❌ Crawlers doesn't see the page's content -->
<div id="root"></div>
```

Whereas with SSR:

```html
<-- ✅ Crawlers sees the page's content -->
<div id="root">
  <h1>Welcome to My Blog</h1>
  <p>This is an article about web development...</p>
</div>
```

> See also: <Link href="/SSR-vs-SPA" />

> Google's crawler is unique because it can also execute client-side JavaScript. This means Google is able to index the content of SPA apps, but it isn't reliable and the common recommendation is still to use SSR even if you only want to target Google. (Also, Google may very well stop doing this since SSR has become a ubiquitous practice.)


## Performance

// TODO: make it more succinct (keep the timeline)

The performance difference between SSR and SPA varies by device:

**Desktop computers** (fast processors, good internet):
- SPA: Usually fine. Client-side JavaScript loads and executes quickly.
- SSR: Slightly faster initial load, but difference is minimal.

**Mobile devices** (slower processors, potentially slow internet):
- SPA: Can be significantly slower. Users might see a blank page for several seconds.
- SSR: Much faster initial load. Users see content immediately while JavaScript loads in the background.

**Example timeline:**

*SPA on mobile:*
1. 0s: User visits page
2. 1s: HTML loads (empty)
3. 3s: JavaScript downloads
4. 5s: JavaScript executes and renders content ← User finally sees content

*SSR on mobile:*
1. 0s: User visits page
2. 1s: HTML loads with content ← User sees content immediately
3. 3s: JavaScript downloads
4. 5s: JavaScript hydrates (makes content interactive)

> See also: <Link href="/SSR-vs-SPA" />


## SPA is a misnomer

TODO: explain why SPA is misnomer. It's usually used to denote "not SSR" but technically/historically it means "SPA fallback".


## See also

- <Link href="/SSR-vs-SPA" />
- <Link href="/hydration" />
- <Link href="/ssr" />
