import { Link } from '@brillout/docpress'
import { ConfigSpec } from '../../components'

<ConfigSpec
  env="server, client"
  cumulative
  global
/>

Hook called whenever a Vike hook is called. Useful for instrumentation (e.g. Sentry, OpenTelemetry).

```ts
// pages/+onHookCall.ts
// Environment: server & client

import type { Config } from 'vike/types'

export const onHookCall: Config['onHookCall'] = async (hook, context) => {
  console.log('before', hook.name, hook.filePath)
  await hook.call()
  console.log('after', hook.name)
}
```

The `hook` object contains:
- `hook.name` — Name of the hook being called (e.g. `'onRenderHtml'`, `'data'`, `'guard'`)
- `hook.filePath` — File path where the hook is defined
- `hook.sync` — Whether the wrapped hook is synchronous
- `hook.call()` — Function to call the actual hook (the return value is handled internally)

The `context` object contains:
- `context.pageContext` — <Link href="/pageContext">`pageContext`</Link> (available for page hooks)
- `context.globalContext` — <Link href="/globalContext">`globalContext`</Link> (always available)

> **Important:** When `hook.sync` is `true`, you must call `hook.call()` synchronously (before any `await`). This is because sync hooks cannot be wrapped asynchronously while preserving synchronous execution.

```ts
// ❌ This breaks sync hooks
export const onHookCall: Config['onHookCall'] = async (hook, context) => {
  await someAsyncOperation()
  await hook.call() // Too late for sync hooks!
}

// ✅ This works for both sync and async hooks
export const onHookCall: Config['onHookCall'] = async (hook, context) => {
  await hook.call() // Called before any await
  await someAsyncOperation()
}
```


## Use case: instrumentation

Instrument hooks with Sentry:

```ts
// pages/+onHookCall.ts
// Environment: server & client

import * as Sentry from '@sentry/node'
import type { Config } from 'vike/types'

export const onHookCall: Config['onHookCall'] = async (hook, context) => {
  await Sentry.startSpan(
    {
      op: 'vike.hook',
      name: hook.name,
      attributes: { filePath: hook.filePath }
    },
    async () => {
      await hook.call()
    }
  )
}
```

Instrument hooks with OpenTelemetry:

```ts
// pages/+onHookCall.ts
// Environment: server & client

import { trace } from '@opentelemetry/api'
import type { Config } from 'vike/types'

const tracer = trace.getTracer('vike')

export const onHookCall: Config['onHookCall'] = async (hook, context) => {
  await tracer.startActiveSpan(hook.name, async (span) => {
    span.setAttribute('hook.filePath', hook.filePath)
    try {
      await hook.call()
    } finally {
      span.end()
    }
  })
}
```

See also: <Link href="/error-tracking" />


## Use case: logging

Log all hook executions for debugging:

```ts
// pages/+onHookCall.ts
// Environment: server & client

import type { Config } from 'vike/types'

export const onHookCall: Config['onHookCall'] = async (hook, context) => {
  const start = performance.now()
  console.log(`[${hook.name}] start`, hook.filePath)
  try {
    await hook.call()
    console.log(`[${hook.name}] done in ${(performance.now() - start).toFixed(2)}ms`)
  } catch (error) {
    console.error(`[${hook.name}] error`, error)
    throw error
  }
}
```


## See also

- <Link href="/hooks" />
- <Link href="/error-tracking" />
- <Link href="/pageContext" />
- <Link href="/globalContext" />
